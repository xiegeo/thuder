//useless code snippets

//pathCompare returns the more "specific" Node by path, to see which should be
//choosen for conflictes. Only called if the two nodes overwrite each other.
func pathCompare(a, b *Node) *Node {
	adl := len(a.fc.from)
	bdl := len(b.fc.from)
	if adl > bdl {
		return a
	}
	if adl < bdl {
		return b
	}
	c := strings.Compare(a.FullName(), b.FullName())
	if c < 0 {
		return a
	}
	return b
}


type PullJob struct {
	Source string //source path
	Target string //target path
}

/*
func (p *PullJob) Do() error {



	fi, err := os.Stat(dir)
	if err != nil {
		return err
	}

	os.Open(name string)

	c := Collection{}
	c.Collect()

	return nil
}

func ChildNodes(dir string, fi os.FileInfo, parent *Node) ([]Node, error) {
	fi, err := os.Stat(filepath.Join(dir, fi.Name()))
	if err != nil{
		return nil, err
	}
	retu &Node{
	fc   *FileContext //allow sharing for node with same context
	info fi
	}
}
*/


		if len(old) == 0 {
			c.nodes[name] = []Node{node}
		} else if node.IsDir() {
			if old[0].IsDir() {
				//add dir to dir list
				c.nodes[name] = append(old, node)
			} else {
				//replace file with new dir list
				c.nodes[name] = []Node{node}
			}
		} else if old[0].IsDir() {
			//keep dir list, ignore new file
		} else if old[0].fc.from != node.fc.from { //files (no folders) only starting here
			//different path, replace
			c.nodes[name] = []Node{node}
		} else if node.IsDelete() {
			//delete duplicate in same path, ignore
		} else if old[0].IsDelete() {
			//replace delete
			c.nodes[name] = []Node{node}
		} else if strings.Compare(old[0].info.Name(), node.info.Name()) > 0 {
			//consistently choose one file
			c.nodes[name] = []Node{node}
		}

		//assertion
		if len(c.nodes[name]) > 1 {
			for _, n := range c.nodes[name] {
				if !n.IsDir() {
					panic("assertion failed: []node longer than 1 must be directories only")
				}
			}
		}